# Gemini CLI React/TypeScript 프로젝트 컨텍스트

이 문서는 Gemini CLI가 이 프로젝트 내에서 작업할 때 필요한 핵심 컨텍스트와 규칙을 제공합니다.

---

## 📁 프로젝트 구조

### 전체 구조

```
front_7th_chapter2-2/
├── packages/
│   ├── react/          # Mini-React 라이브러리 (핵심 구현)
│   └── app/            # React 애플리케이션 (사용 예제)
├── .cursor/
│   └── mockdowns/      # 구현 문서 및 학습 자료
├── docs/               # 프로젝트 문서
└── e2e/                # E2E 테스트
```

### Monorepo 구조

-   **패키지 관리**: `pnpm workspace` 사용
-   **루트 패키지**: `front-chapter2-2`
-   **React 패키지**: `@hanghae-plus/react` (Mini-React 구현)
-   **App 패키지**: `@hanghae-plus/shopping` (React 애플리케이션)

---

## 🎯 packages/react 구조

### 디렉토리 구조

```
packages/react/src/
├── core/               # 핵심 시스템 (렌더링, 재조정 등)
├── hooks/              # 추가 Hook 구현
├── hocs/               # 고차 컴포넌트
├── utils/              # 유틸리티 함수
├── client/             # 클라이언트 진입점
└── index.ts            # 메인 export
```

---

## 🔧 핵심 시스템 (`core/`)

-   **Context (`context.ts`)**: 훅, 이펙트, 렌더링 루트 등 전역 상태 관리
-   **Hooks (`hooks.ts`)**: `useState`, `useEffect` 등 기본 훅
-   **Reconciler (`reconciler.ts`)**: 가상 DOM 비교 및 재조정 알고리즘
-   **Render (`render.ts`)**: 실제 DOM 렌더링 로직

---

## 🪝 Hook 시스템 상세 (`hooks/`, `core/hooks.ts`)

-   **상태 관리**: 컴포넌트 경로(`path`)와 훅 호출 순서(`cursor`)를 조합하여 각 훅의 상태를 고유하게 식별하고 격리합니다.
-   **기본 훅**: `useState`, `useEffect`
-   **추가 훅**: `useRef`, `useMemo`, `useCallback`, `useAutoCallback`, `useDeepMemo`
-   **상세 구현**: 각 훅은 `useRef`나 `useState`를 기반으로 메모이제이션 및 상태 보존을 구현합니다.

---

## 🎨 고차 컴포넌트 (HOC) (`hocs/`)

-   **`memo`**: props를 얕게 비교(`shallowEquals`)하여 변경이 없을 경우 리렌더링을 방지합니다.
-   **`deepMemo`**: props를 깊게 비교(`deepEquals`)하여 리렌더링을 방지합니다.
-   **구현 방식**: `useRef`를 사용하여 이전 props와 렌더링 결과를 저장하고, 비교 함수를 통해 재사용 여부를 결정합니다.

---

## 🚀 핵심 작업 원칙 및 흐름

### 1. 핵심 원칙

-   **최소 변경 원칙**: 요청된 기능과 직접적으로 관련된 코드만 수정합니다. 리팩토링이나 관련 없는 기능 수정이 필요하면 작업을 멈추고 사용자에게 먼저 확인받습니다.
-   **최소 구현 원칙**: 요청된 기능을 최소한의 범위로 구현하며, 불필요한 기능을 추가하지 않습니다.
-   **주석 기반 개발**: 코드 작성 전, 주변 코드와 주석을 통해 의도를 파악합니다. 주석이 명확하지 않으면 사용자에게 질문합니다.
-   **코드 가독성**: 복잡한 로직은 다른 개발자가 쉽게 이해할 수 있도록 상세한 주석을 추가합니다.
-   **ESLint 규칙 준수**: ESLint 에러 발생 시, `// eslint-disable-next-line` 주석을 사용하여 명시적으로 규칙을 비활성화하고 넘어갑니다.

### 2. 작업 흐름

엄격하게 아래 순서를 따릅니다.

1.  **구조 파악**: 관련된 파일들의 코드와 전체 구조를 먼저 이해합니다.
2.  **계획 수립**: 분석한 내용을 바탕으로 명확한 실행 계획을 세웁니다.
3.  **문제 분석**: 버그, 또는 구현할 기능의 핵심 원인을 파악하고 해결 방안을 구체화합니다.
4.  **작업 실행**: 계획에 따라 코드를 작성하거나 수정합니다.
5.  **테스트 요청 (⭐ 중요)**:
    -   **AI는 테스트를 직접 실행하지 않습니다.**
    -   테스트가 필요한 시점(코드 수정 완료 후)에 작업을 중단하고, 사용자에게 테스트 실행을 요청합니다.
    -   **요청 예시**: "수정 작업이 완료되었습니다. `pnpm test`를 실행하여 결과를 알려주시면 다음 단계를 진행하겠습니다."
6.  **결과 기반 작업**: 사용자가 전달한 테스트 결과를 바탕으로 디버깅, 추가 수정 등 후속 작업을 진행합니다.
7.  **완료 보고**: 모든 작업 완료 후, 변경 사항, 핵심 로직, 그리고 필요 시 다음 단계에 대해 명확하게 요약하여 보고합니다.

---

## 🧪 테스트 규칙

-   **사용자 주도 테스트**: 모든 테스트는 사용자가 직접 실행합니다. AI는 작업 후 테스트를 요청하고 결과를 기다립니다.
-   **테스트 실행 도구**: `pnpm`을 사용한 테스트 실행을 권장합니다.
-   **테스트 단위**: 테스트는 작은 `it` 단위로 확인하는 것을 원칙으로 합니다.

---

## 📝 산출물 관리

-   **저장 위치**: 작업 계획, 분석 등 모든 산출물은 `.cursor/mockdowns/react-implementation/` 디렉토리에 저장합니다.
-   **파일명**: `[숫자(01)]_[주제].md` 형식 (예: `01_memo-bug-analysis.md`)을 따릅니다.
-   **문서 통합**: 특정 문제와 관련된 산출물은 여러 개로 분산시키지 않고, **하나의 문서로 통합**하여 지속적으로 업데이트합니다.

---

## 🌐 언어 및 보고 규칙

-   **작업 언어**: AI 내부의 논리적 분석, 계획 등은 정확성을 위해 **영문**으로 사고(think)할 수 있습니다.
-   **사용자 소통 언어**: 사용자에게 보여주는 모든 결과물(주석, 보고, 질문 등)은 명확한 소통을 위해 **한글**로 작성합니다.
-   **작업 보고**: 작업 완료 시, 변경된 내용과 핵심 로직을 사용자가 이해하기 쉽게 요약하여 보고합니다.

---

## 📚 참고 자료

-   `.cursor/mockdowns/react-implementation/`: 구현 상세 문서
-   `.cursor/mockdowns/study/`: 학습 자료
-   `packages/react/src/__tests__/`: 단위 테스트 파일

